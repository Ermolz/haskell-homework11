# Робота №11  
**Тема:** Збалансовані дерева пошуку (2–3-дерева)

---

## 1. Означення 2–3-дерева

**2–3-дерево** (збалансоване дерево пошуку) — це дерево, у якого:

- кожен внутрішній вузол (що не є листком) має **двох** або **трьох** синів;
- **усі шляхи** від кореня до листків мають **однакову довжину**;
- порожнє дерево і дерево з одним листком також вважаються 2–3-деревами;
- усі записи з ключами зберігаються **в листках**;
- у внутрішніх вузлах зберігаються ключі, які використовуються для ефективної навігації по дереву;
- для спрощення вважаємо, що запис складається лише з **одного ключа**.

Одна й та сама множина записів може бути представлена **різними** 2–3-деревами. Два 2–3-дерева, які задають одну й ту ж множину записів, називаються **еквівалентними**.  
2–3-дерево може містити кілька записів з однаковими ключами (тобто задавати мультимножину). :contentReference[oaicite:0]{index=0}

---

## 2. Тип даних `Tree23`

Означення типу 2–3-дерева, де запис містить лише ключ:

```haskell
data Tree23 a  = Leaf a
               | Node2 (Tree23 a) a (Tree23 a)
               | Node3 (Tree23 a) a (Tree23 a) a (Tree23 a)
               | Empty23     -- порожнє 2-3-дерево!!!
                   deriving (Eq, Show)
````

---

## 3. Характеристики 2–3-дерева

Для кожного 2–3-дерева вводяться такі характеристики:

* **Висота** — довжина найдовшого шляху від кореня до одного з листків.
  Для порожнього дерева висота вважається рівною `-1`.

* **Мінімальне та максимальне значення ключа** — визначаються тільки для дерев, які **не** містять жодного вузла `Empty23`.

---

## 4. Властивості 2–3-дерева

2–3-дерево може бути:

1. **Порожнім:**

   ```haskell
   Empty23
   ```

2. **Непорожнім**, тоді можливі три види вершин:

   * **Листок**:

     ```haskell
     Leaf k
     ```

     Містить одне значення `k`.

   * **2-вузол**:

     ```haskell
     Node2 tl x tr
     ```

     Вузол із одним ключем `x`, лівим піддеревом `tl` та правим піддеревом `tr`.
     Властивості:

     * для всіх значень `v` з піддерева `tl` виконується `v <= x`;
     * значення `x` є **мінімальним** у піддереві `tr`.

   * **3-вузол**:

     ```haskell
     Node3 tl x tm y tr
     ```

     Вузол із двома ключами `x`, `y` та трьома піддеревами `tl`, `tm`, `tr`.
     Властивості:

     * для всіх значень `v` з піддерева `tl` виконується `v <= x`;
     * значення `x` є **мінімальним** у піддереві `tm`;
     * для всіх значень `v` з піддерева `tm` виконується `v <= y`;
     * значення `y` є **мінімальним** у піддереві `tr`.

* **Усі листки** дерева знаходяться на **одному рівні**.

---

## 5. Пошук у 2–3-дереві

Щоб знайти запис з ключем `v`, потрібно:

1. Почати з кореня дерева.
2. Якщо вузол — внутрішній (`Node2` або `Node3`), порівняти ключ `v` з ключами вузла:

   * у випадку `Node2 tl x tr` вирішуємо, йти в `tl` чи `tr`;
   * у випадку `Node3 tl x tm y tr`:

     * якщо `v < x`, йдемо в `tl`;
     * якщо `x <= v < y`, йдемо в `tm`;
     * якщо `v >= y`, йдемо в `tr`.

Процес триває, поки не дійдемо до відповідного листка.

---

## 6. Вставка нового запису

Вставка нового запису з ключем `v` у 2–3-дерево виконується у три етапи:

1. **Пошук місця вставки**

   Виконується прохід від кореня до **термінального вузла** — внутрішнього вузла, всі сини якого є листками. Саме в такого вузла один із синів має стати новим листком з ключем `v`.

2. **Вставка в термінальний вузол**

   * Якщо вузол-термінал має **два листки**, після вставки утворюється новий термінальний вузол із **трьома** листками (результат — одне нове піддерево).
   * Якщо вузол має **три листки**, після вставки утворюються **два** нових термінальних вузли (результат — два піддерева), і далі потрібне коригування при підйомі до кореня.

3. **Коригування**

   Повертаючись шляхом до кореня:

   * якщо внаслідок вставки з’явився додатковий вузол, потрібно **відновити баланс по висоті**;
   * це може призвести до **збільшення висоти** всього 2–3-дерева.

---

## 7. Допоміжні функції для вставки

У допоміжному файлі вже задані типи та частина функцій.

### 7.1. `isTerminal`

```haskell
isTerminal :: (Ord a) => Tree23 a -> Bool
```

* Перевіряє, чи є корінь 2–3-дерева **термінальним вузлом**, тобто всі його сини — листки.

### 7.2. `insTerm`

```haskell
insTerm :: (Ord a) => a -> Tree23 a -> (Tree23 a, Maybe (a, Tree23 a))
```

* Додає значення `v` у 2–3-дерево `tr`, корінь якого є **термінальним вузлом**.
* Повертає один із двох варіантів:

  * `(t1, Nothing)` — отримано **одне** нове розширене дерево `t1`;
  * `(t1, Just (w, t2))` — отримано **два** нових дерева `t1` і `t2`, причому `w` — найменший ключ у дереві `t2`.

### 7.3. `insNode`

```haskell
insNode :: (Ord a) => a -> Tree23 a -> (Tree23 a, Maybe (a, Tree23 a))
```

* Вставляє значення `v` у 2–3-дерево `t`, корінь якого — **нетермінальний вузол** (`Node2` або `Node3`).
* Результат аналогічний `insTerm`:

  * `(t1, Nothing)` — одне нове дерево;
  * `(t1, Just (w, t2))` — два дерева та ключ `w`, який піднімається «догори» для корекції батьківського вузла.

---

## 8. Завдання

На основі допоміжного файлу (де вже визначені типи, допоміжні функції та дерева для тестування) потрібно створити файл, у якому реалізувати наступні функції: 

---

### 8.1. Функція `h23`

```haskell
h23 :: (Ord a) => Tree23 a -> Int
```

Обчислює **висоту** 2–3-дерева `tr`.

Приклади:

```haskell
h23 Empty23 = -1

h23 (Node2 (Leaf 0) 1 (Leaf 2)) = 1

h23 tr5 = 3
```

---

### 8.2. Функція `minmax23`

```haskell
minmax23 :: (Ord a) => Tree23 a -> Maybe (a, a)
```

Для 2–3-дерева `tr`:

* якщо дерево **не містить жодного вузла** `Empty23`, повертає `Just (min, max)`, де `min` — мінімальний ключ у дереві, `max` — максимальний;
* якщо хоч один вузол `Empty23` зустрічається всередині — повертає `Nothing`.

Приклади:

```haskell
minmax23 (Node2 (Leaf 1) 0 Empty23) = Nothing

minmax23 (Node2 (Leaf 1) 0 (Leaf 2)) = Just (0, 2)

minmax23 tr5 = Just (2, 19)
```

---

### 8.3. Предикат `isTree23`

```haskell
isTree23 :: (Ord a) => Tree23 a -> Bool
```

Перевіряє, чи є об’єкт `tr` типу `Tree23` **коректним 2–3-деревом** (з урахуванням усіх властивостей з розділу 4).

Приклади:

```haskell
isTree23 (Node2 (Leaf 0) 1 (Leaf 2)) = False

isTree23 tr3 = True
```

---

### 8.4. Предикат `eqTree23`

```haskell
eqTree23 :: (Ord a) => Tree23 a -> Tree23 a -> Bool
```

Перевіряє, чи є два 2–3-дерева `tr1` і `tr2` **еквівалентними**, тобто задають **одну й ту ж множину записів**.

Приклад:

```haskell
eqTree23 tr1 tr2 = True
```

---

### 8.5. Предикат `elemTree23`

```haskell
elemTree23 :: (Ord a) => Tree23 a -> a -> Bool
```

Перевіряє, чи містить 2–3-дерево `tr` значення `v`.

Приклади:

```haskell
elemTree23 tr3 12 = True

elemTree23 tr3 13 = False
```

---

### 8.6. Функція `insNode`

```haskell
insNode :: (Ord a) => a -> Tree23 a -> (Tree23 a, Maybe (a, Tree23 a))
```

Реалізує вставку значення `v` у дерево `tr`, корінь якого — вузол типу `Node2` або `Node3`.
При реалізації можна (і треба) використовувати вже дані функції:

* `insert`
* `insTerm`
* `insTree23`

Приклади:

```haskell
insNode 18 tr3 = (tr4, Nothing)

insTree23 tr4 10 = tr5
```

---

### 8.7. Функція `sortList`

```haskell
sortList :: (Ord a) => [a] -> [a]
```

Сортує список `l`, використовуючи збалансовані 2–3-дерева:

1. Починаючи з порожнього дерева `Empty23`, послідовно вставляємо всі елементи списку `l` за допомогою `insTree23` (зручно через `foldl`).
2. Отримуємо 2–3-дерево.
3. Формуємо **відсортований список**, проходячи листки дерева **зліва направо**.

Приклади:

```haskell
sortList "bca" = "abc"

sortList "Capablanca" = "Caaaabclnp"
```

---

## 9. Сигнатури функцій

Для зручності всі типи ще раз:

```haskell
h23       :: (Ord a) => Tree23 a -> Int

minmax23  :: (Ord a) => Tree23 a -> Maybe (a, a)

isTree23  :: (Ord a) => Tree23 a -> Bool

eqTree23  :: (Ord a) => Tree23 a -> Tree23 a -> Bool

elemTree23 :: (Ord a) => Tree23 a -> a -> Bool

insNode   :: (Ord a) => a -> Tree23 a -> (Tree23 a, Maybe (a, Tree23 a))

sortList  :: (Ord a) => [a] -> [a]
```